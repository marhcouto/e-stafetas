\chapter{Prospective Solution}

\section{Pre-Processing of Input Data}
Before going through with the problem resolution and trying to find the shortest path for the vehicles, we opt to pre-process the graph, discarding unnecessary nodes and edges. By reducing the number of nodes and edges we analyse we are able improve the temporal spacial efficiency of all other algorithms. 


\subsection{Graph Pre-Processing}
\begin{itemize}
    \item evaluating the connectivity of the graph (algorithm described further ahead), therefore checking for any inaccessible nodes or blocked edges (result of accidents or road works) followed by removal of the irrelevant elements
    \item 
\end{itemize}


\subsection{Order Pre-Processing}
\begin{itemize}
    \item check if any of the pick up or delivery point are not present in the map. If this is the case for any order, it must be removed
\end{itemize}



\section{Problem Identification}

With the graph and the orders pre-processed, there's now a need to find the most efficient way for the vehicles to pick up and deliver the costumers' orders. Before, we have divided the problem into four iterations 
\begin{itemize}
    \item \textbf{I} - Calculation of shortest paths
    \item \textbf{II} -Evaluation of the graph's connectivity
    \item \textbf{III} -Inclusion of recharging points in the paths as needed
    \item \textbf{IV} -Distribution of the orders between the vehicles available to the company
\end{itemize}



\section{Shortest Path Between Two Nodes}

Algorithms for the calculation of the Shortest Path between two points are very important for the solution of this problem. They will be used to calculate the shortest path between multiple points when calculating a vehicle's path, such as the shortest path between the garage and a pick up point. To do this, there are many algorithms at our disposal. We will evaluate some of them and make a decision on which is(are) best for the situation at hand.


\subsection{Dijkstra's Algorithm}

\subsubsection{Description}
This algorithm was conceived by Edsger W. Dijkstra in 1956 and is used to calculate shortest paths in directed or undirected graphs, so long there are no edges with negative weight. Upon utilization of this algorithm, a tree holding the shortest paths from the origin node to all others is formed. 

\subsubsection{Extra Data and Data Structures Required}
\begin{itemize}
    \item Minimum distance to the origin node from each of the graph's nodes (dist)
    \item Node that comes before it in its path (path)
    \item Priority queue to hold the nodes to be processed next
\end{itemize}

\input{Algorithms/Dijkstra.tex}

\subsubsection{Analysis}
The first part of the algorithm's goal is to prepare the data: paths are set to null, distances to infinity, the priority queue is initialized and the origin node is inserted. Then, a breadth-first search is performed; a check is made to every node found in order to understand if its path can be shortened by the use of the edge in analysis. After that, if the node is not already in the queue, it must be inserted, to be eventually processed. If it is, its key must be reduced. The items of the priority queue are ordered by their key. This system is used so that the nodes which are closest to the origin are processed first. This procedure ensures that the distance of already processed nodes remains intact, boosting the algorithm's efficiency and making this a greedy algorithm. \\
\uline{Note:} Processing a node is used as: cycling through the nodes edges (line 11)

\subsubsection{Efficiency}
\begin{itemize}
    \item \textbf{Temporal Complexity} - $ O((|N|+|E|) \times \log(|N|) $, where E is the set of edges and N the set of nodes of the graph. Decrease-Key's time efficiency is $ O(|E| \times log(|N|)$. It can be $ O(1) $ if Fibonacci Heaps are used instead of regular Priority Queues, making the whole algorithm $ O(|V| \times log(|V|) $ 
    \item \textbf{Spatial Complexity} - Depends on the implementation, but usually $ O(|V|) $
\end{itemize}

\subsubsection{Usability}
This algorithm is one to consider using in the problem, but there may be slightly more efficient ones.


\subsection{Bellman-Ford Algorithm}

\subsubsection{Description}
The Bellman-Ford Algorithm is another algorithm used to calculate the shortest path between nodes in a graph. It was first proposed by Alfonso Shimbel in 1955 but ended up being named after Richard Bellman and Lester Ford, who later officially published it independently. This algorithm is useful to calculate shortest paths in graphs with negative weight edges and to detect negative edge cycles in them.

\subsubsection{Extra Data and Data Structures Required}
\begin{itemize}
    \item Minimum distance to the origin node from each of the graph's nodes (dist)
    \item Node that comes before it in its path (path)
\end{itemize}

\input{Algorithms/Bellman-Ford.tex}

\subsubsection{Analysis}
In this algorithm, the first step is to prepare the graph (lines 1-4). Then, all edges are analyzed $|N| - 1 $ times, checking if they can be used to shorten the path from s to the destination node of the edge. This process is repeated this amount of times because it is the maximum length in edges for a path.

\subsubsection{Efficiency}
\begin{itemize}
    \item \textbf{Temporal Complexity} - $ O(|N| \times |E|) $, where E is the set of edges and N the set of nodes of the graph
    \item \textbf{Spatial Complexity} - Depends on the implementation, but in this case $ O(1) $
\end{itemize}

\subsubsection{Usability}
This algorithm poses little interest to this problem given that our edges' weights represent the length of a road, which would never be negative. 


\subsection{Bi-directional Dijkstra}

\subsubsection{Description}
Ira Pohl was the first one to design and implement a bi-directional heuristic search algorithm in 1971. Search trees emanating from the start and goal nodes failed to meet in the middle of the solution space. The BHFFA algorithm fixed this defect Champeaux in 1977. % O que é?
Bidirectional search is a graph search algorithm that finds a shortest path from an initial vertex to a goal vertex in a directed graph. It runs two simultaneous searches: one forward from the initial state, and one backward from the goal, alternating between the two and stopping when the two meet.
Compared to normal Dijkstra there's a speedup of 2x. The processed area is 2.pi.r instead of 4.pi.r. % O que é?

\subsubsection{Extra Data and Data Structures Required}
\begin{itemize}
    \item Minimum distance to the origin or goal node from each of the graph's nodes (dist)
    \item Node that comes before it in its path (path)
    \item Two priority queues to hold the nodes to be processed next in each direction
    \item Boolean to say if the
\end{itemize}
\input{Algorithms/Bidirectional.tex}


\section{Shortest Path Between All Nodes}

\subsection{Floyd-Warshall}
This algorithm was published by Roberto Floyd in 1962.
It takes an adjacency matrix that represents the graph as an input. The value of a path between to vertices is the sum of all edge's weights through that path. Edges may have negative values but the graph can't have a negative cycle.
For each pair of vertices the shortest path is calculated. Time complexity is O \begin{math}(|V| ^3).\end{math}, and space complexity is O \begin{math}(|V| ^2).\end{math}



