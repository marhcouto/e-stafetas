\chapter{Algorithms}
In this chapter, we will list some important algorithms which may be used in the solution of each subproblem.

\section{Shortest Path Between Two Nodes}

Algorithms for the calculation of the Shortest Path between two points are very important for the solution of this problem. They will be used to calculate the shortest path between multiple points when calculating a vehicle's path, such as the shortest path between the garage and a pick up point. To do this, there are many algorithms at our disposal. We will evaluate some of them and make a decision on which is(are) best for the situation at hand.


\subsection{Dijkstra's Algorithm}

\subsubsection{Description}
This algorithm was conceived by Edsger W. Dijkstra in 1956 and is used to calculate shortest paths in directed or undirected graphs, so long there are no edges with negative weight. Upon utilization of this algorithm, a tree holding the shortest paths from the origin node to all others is formed. 

\subsubsection{Extra Data, Data Structures and Algorithms Required}
\begin{itemize}
    \item Minimum distance to the origin node from each of the graph's nodes (dist)
    \item Node that comes before it in its path (path)
    \item Priority queue to hold the nodes to be processed next
    \item Decrease-Key function, to maintain the nodes with shortest distance in the top of the queue
\end{itemize}

\input{Algorithms/Dijkstra.tex}

\subsubsection{Analysis}
The first part of the algorithm's goal is to prepare the data (lines 1-6): paths are set to null, distances to infinity, the priority queue is initialized and the origin node is inserted. Then, a breadth-first search is performed; a check is made to every node found in order to understand if its path can be shortened by the use of the edge in analysis. After that, if the node is not already in the queue, it must be inserted, to be eventually processed. If it is, its key must be reduced. The items of the priority queue are ordered by their key. This system is used so that the nodes which are closest to the origin are processed first. This procedure ensures that the distance of already processed nodes remains intact, boosting the algorithm's efficiency and making this a greedy algorithm. \\
\begin{itemize}
    \item \textbf{Loop invariant} - $ priorityQueue \neq \emptyset $, as each time a node is processed, its shortest path is defined and all nodes will be processed when the queue is empty
    \item \textbf{Loop variant} - the number of nodes to be processed, since the algorithm would stop when the queue is empty
\end{itemize}

\subsubsection{Efficiency}
\begin{itemize}
    \item \textbf{Temporal Complexity} - $ O((|N|+|E|) \times \log(|N|) $, where E is the set of edges and N the set of nodes of the graph. Decrease-Key's time efficiency is $ O(|E| \times log(|N|)$. It can be $ O(1) $ if Fibonacci Heaps are used instead of regular Priority Queues, making the whole algorithm $ O(|V| \times log(|V|) $ 
    \item \textbf{Spatial Complexity} - Depends on the implementation, but usually $ O(|V|) $
\end{itemize}

\subsubsection{Usability}
This algorithm is one to consider using in the problem, but there may be slightly more efficient ones.


\subsection{Bellman-Ford Algorithm}

\subsubsection{Description}
The Bellman-Ford Algorithm is another algorithm used to calculate the shortest path between nodes in a graph. It was first proposed by Alfonso Shimbel in 1955 but ended up being named after Richard Bellman and Lester Ford, who later officially published it independently. This algorithm is useful to calculate shortest paths in graphs with negative weight edges and to detect negative edge cycles in them.

\subsubsection{Extra Data, Data Structures and Algorithms Required}
\begin{itemize}
    \item Minimum distance to the origin node from each of the graph's nodes (dist)
    \item Node that comes before it in its path (path)
\end{itemize}

\input{Algorithms/Bellman-Ford.tex}

\subsubsection{Analysis}
In this algorithm, the first step is to prepare the graph (lines 1-4). Then, all edges are analyzed $|N| - 1 $ times(lines 6-7), checking if they can be used to shorten the path from s to the destination node of the edge(line 8). This process is repeated this amount of times because it is the maximum length in edges for a path. In the end, a check is made, to see if the algorithm worked. If it did not, the cycle as negative weight loops (lines 14-18). This algorithm is considered to implement dynamic programming.

\subsubsection{Efficiency}
\begin{itemize}
    \item \textbf{Temporal Complexity} - $ O(|N| \times |E|) $, where E is the set of edges and N the set of nodes of the graph
    \item \textbf{Spatial Complexity} - Depends on the implementation, but in this case $ O(1) $
\end{itemize}

\subsubsection{Usability}
This algorithm poses little interest to this problem given that our edges' weights represent the length of a road, which would never be negative. 


\subsection{Bi-directional Dijkstra}

\subsubsection{Description}
Ira Pohl was the first one to design and implement a bi-directional heuristic search algorithm in 1971. 
Bidirectional search (in this case, Bidirectional Dijkstra's) is a graph search algorithm that finds a shortest path from an initial node to a goal node in a directed or undirected graph. It runs two simultaneous searches: one forward from the initial state, and one backward from the goal, alternating between the two. The stopping criteria is one that must be very well implemented to guarantee the shortest path. Compared to normal Dijkstra there's a speedup of 2x.

\subsubsection{Extra Data, Data Structures and Algorithms Required}
\begin{itemize}
    \item Minimum distances to the origin and goal nodes from each of the graph's nodes (dist)
    \item Nodes that come before each node in both forward and backward paths (not implemented in pseudocode)
    \item Two priority queues to hold the nodes to be processed next in each direction
    \item Way of search (way) (1 if it was encountered by forward search first, 2 if it was encountered by backward search first, 0 default)
    \item Decrease-Key function, to maintain the nodes with shortest distance in the top of the queue
\end{itemize}

\input{Algorithms/Bidirectional.tex}
\uline{Note:} The pseudocode is not complete, missing the parts to calculate the actual path and to calculate the reverse graph (needed for the backward search because this is a directed graph). These parts were excluded in order to not make the algorithm's pseudocode even more complex and spatious.

\subsubsection{Analysis}
This algorithm basically performs two Dijkstra's algorithms: one starting from the initial node and going forward(lines 16-23); another one starting from the ending node and going backward (lines 24-31). Each time they cross, the distance is registered (lines 25-26 for example). The stopping criteria is a tricky problem in this case. In many situations, the algorithm ends when the two sets collide (forward search and backward search). We found that this criteria did not guarantee the shortest path. Instead, we chose to end the algorithm when there can be no longer any better distances because the nodes being processed are already too far apart.
\begin{itemize}
    \item \textbf{Loop invariant} - $ dist(n) + distR(v) > bestDist $, where best distance is the best Distance for a complete path obtained yet, dist(n) is the distance of the node being processed in forward way to the starting node and $ distR(v) $ the distance of the node being processed in backward way to the ending node
    \item \textbf{Loop variant} - the number of nodes to be processed in each way, since the algorithm would stop when each search had got no more nodes to process on the queue
\end{itemize}

\subsubsection{Efficiency}
\begin{itemize}
    \item \textbf{Temporal Complexity} - $ O((|N|+|E|) \times \log(|N|) $, where E is the set of edges and N the set of nodes of the graph.
    \item \textbf{Spatial Complexity} - Depends on the implementation, but usually $ O(|V|) $
\end{itemize}
Eventhough there's a speed up, the complexities will be the same as in Dijkstra's, since the difference is multiplication and division by constants, which is ignored in Big O order.

\subsubsection{Usability}
Bidirectional Dijkstra's algorithm is one of the fastest algorithms when it comes shortest paths. It has the down-side of requiring the previous knowledge of the ending/destination node, but in this scenario that is not a problem.



\section{Shortest Path Between All Nodes}


\subsection{Floyd-Warshall}

\subsubsection{Description}
This algorithm was published by Robert Floyd in 1962, yet it was virtually the same as some algorithms published by Stephen Warshall and Bernard Roy, 1962 and 1959 respectively. It takes an adjacency matrix that represents the graph as an input (empty in the beggining) and calculates the shortest paths between all nodes. The value of a path between to vertices is the sum of all edge's weights through that path. It is registered in the matrix as such: distance of shortest path between 1 and 4 would be matrix[1][4]. Edges may have negative values but the graph can't have a negative cycle.
% For each pair of vertices, the shortest path is calculated. Time complexity is O \begin{math}(|V| ^3).\end{math}, and space complexity is O \begin{math}(|V| ^2).\end{math}

\subsubsection{Extra Data, Data Structures and Algorithms Required}